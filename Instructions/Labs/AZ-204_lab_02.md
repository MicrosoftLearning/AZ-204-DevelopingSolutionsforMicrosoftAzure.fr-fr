---
lab:
  az204Title: 'Lab 02: Implement task processing logic by using Azure Functions'
  az204Module: 'Module 02: Implement Azure Functions'
---

# Lab 02 : Implémenter une logique de traitement des tâches à l’aide d’Azure Functions

## Interface utilisateur Microsoft Azure

Étant donné la nature dynamique des outils cloud Microsoft, il se peut que vous constatiez des modifications de l’interface utilisateur Azure après le développement du contenu de cette formation. Il se peut donc que certaines instructions et étapes du labo ne s’alignent pas correctement.

Microsoft met ce cours à jour quand la communauté l’alerte sur la nécessité d’y apporter des modifications. Toutefois, compte tenu de la fréquence des mises à jour cloud, il se peut que vous rencontriez des modifications de l’interface utilisateur avant les mises à jour du contenu de cette formation. **Si cela se produit, adaptez-vous aux changements, puis appliquez-les dans les laboratoires si nécessaire.**

## Instructions

### Avant de commencer

#### Se connecter à l’environnement de labo

Connectez-vous à votre machine virtuelle Windows 10 en utilisant les informations d’identification suivantes :

- Nom d’utilisateur : **Administrateur**
- Mot de passe : **Pa55w.rd**

> **Remarque** : Votre instructeur vous fournira des instructions pour la connexion à l’environnement de laboratoire virtuel.

#### Passer en revue les applications installées

Localisez la barre des tâches sur votre bureau Windows 10. La barre des tâches contient les icônes des applications que vous allez utiliser dans ce labo, à savoir:

- Microsoft Edge
- Explorateur de fichiers
- Terminal Windows
- Visual Studio Code

## Diagramme de l'architecture

![Diagramme d’architecture montrant un utilisateur en train d’implémenter une logique de traitement des tâches à l’aide d’Azure Functions.](./media/Lab02-Diagram.png)

### Exercice 1 : Créer des ressources Azure

#### Tâche 1 : Ouvrir le portail Azure

1. Dans la barre des tâches, sélectionnez l’icône **Microsoft Edge**.
1. Dans la fenêtre du navigateur, accédez au portail Azure (<https://portal.azure.com>), puis connectez-vous au compte que vous allez utiliser pour ce laboratoire.

    > **Remarque** : Si vous vous connectez au portail Azure la première fois, une visite guidée du portail vous sera proposée. Si vous préférez faire l’impasse sur la visite, sélectionnez **Prise en main** pour commencer à utiliser le portail.

#### Tâche 2 : Créer un compte de stockage Azure

1. Dans le portail Azure, utilisez la zone de texte **Rechercher des ressources, des services et des documents** pour rechercher **Comptes de stockage**, puis, dans la liste des résultats, sélectionnez **Comptes de stockage**.

1. Dans le volet **Comptes de stockage**, sélectionnez **+ Créer**.

1. Dans le volet **Créer un compte de stockage**, sous l’onglet **Informations de base**, effectuez les actions suivantes, puis sélectionnez **Vérifier** :

    | Paramètre | Action |
    | -- | -- |
    | Liste déroulante  **Abonnement** | Conservez les valeurs par défaut. |
    | Section **Groupe de ressources** | Sélectionnez **Créer**, entrez **Serverless**, puis sélectionnez **OK** |
    | Zone de texte **Nom de compte de stockage** | Entrez **funcstor** _[votrenom]_ . |
    | Liste déroulante **Région** | Sélectionnez **(États-Unis) USA Est** |
    | Section **Performance** | Sélectionnez l’option **Standard**. |
    | Liste déroulante **Redondance** | Sélectionner **Stockage localement redondant (LRS)** |

    La capture d’écran suivante affiche les paramètres configurés dans le volet **Créer un compte de stockage**.

    ![Capture d’écran montrant les paramètres configurés dans le volet Créer un compte de stockage.](./media/l02_create_a_storage_account.png)

1. Sous l’onglet **Vérifier**, passez en revue les options que vous avez sélectionnées dans les étapes précédentes.

1. Sélectionnez **Créer** pour créer le compte de stockage à l’aide de votre configuration spécifiée.

    > **Remarque** : attendez que la tâche soit créée avant de poursuivre ce labo.

1. Dans le volet **Vue d’ensemble**, sélectionnez le bouton **Accéder à la ressource** pour accéder au volet du compte de stockage nouvellement créé.

1. Dans le volet **Compte de stockage**, dans la section **Sécurité + réseau**, sélectionnez **Clés d’accès**.

1. Dans le volet **Clés d’accès**, sélectionnez **Afficher les clés**.

1. Examinez chacune des clés, puis copiez la valeur de l’une des zones **Chaîne de connexion** dans le Presse-papiers.

     > **Remarque** : peu importe la chaîne de connexion que vous choisissez. Ils sont interchangeables.

1. Ouvrez Bloc-notes et collez-y la valeur de chaîne de connexion copiée. Vous allez utiliser cette valeur plus loin dans ce labo.

#### Tâche 3 : Créer une application de fonction

1. Dans le volet de navigation du portail Azure, sélectionnez le lien **Créer une ressource**.

1. Dans le volet **Créer une ressource**, dans la zone de texte **Rechercher dans les services et la Place de marché**, entrez **Fonction**, puis sélectionnez Entrée.

1. Dans le volet des résultats de la recherche dans la **Place de marché**, sélectionnez le résultat **Application de fonction**.

1. Dans le panneau **Application Function**, sélectionnez **+ Créer**.

1. Dans le volet **Créer une application de fonction**, sous l’onglet **Options de base**, effectuez les actions suivantes, puis sélectionnez **Suivant: Hébergement**:

    | Paramètre | Action |
    | -- | -- |
    | Liste déroulante  **Abonnement** | Conservez les valeurs par défaut. |
    | Section **Groupe de ressources** | Sélectionnez **Serverless** |
    | Zone de texte **Nom de l’application de fonction** | Entrez **funclogic** _[votrenom]_ |
    | Section **Publier** | Sélectionner **Code** |
    | Liste déroulante **Pile d’exécution** | Sélectionnez **.NET**. |
    | Liste déroulante **Version** | Sélectionnez **6** |
    | Liste déroulante **Région** | Sélectionnez la région **USA Est** |
    | Option **Système d’exploitation** | Sélectionnez **Linux** |
    | Liste déroulante **Type de plan** | Sélectionnez **Consommation (serverless)** . |

    La capture d’écran suivante affiche les paramètres configurés dans le volet **Créer une application de fonction**.

    ![Capture d’écran montrant les paramètres configurés dans le volet Créer une application de fonction](./media/l02_create_a_function_app.png)

1. Sous l’onglet **Hébergement**, effectuez les actions suivantes, puis sélectionnez **Vérifier + créer** :

    | Paramètre | Action |
    | -- | -- |
    | Liste déroulante **Compte de stockage**. | Sélectionnez le compte de stockage **funcstor** _[votrenom]_ |

1. Sous l’onglet **Vérifier + créer**, passez en revue les options que vous avez sélectionnées lors des étapes précédentes.

1. Sélectionnez **Créer** pour créer l’application de fonction à l’aide de votre configuration spécifiée.

    > **Remarque** : Attendez que la tâche de création soit terminée avant de poursuivre ce labo.

#### Révision

Dans cet exercice, vous avez créé toutes les ressources que vous allez utiliser dans ce labo.

### Exercice 2 : Configurer un projet Azure Functions local

#### Tâche 1 : Initialiser un projet de fonction

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.

1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire vide **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

    > **Remarque** : dans l’Explorateur Windows, supprimez l’attribut **Read-only** du fichier **F:\\Allfiles\\Labs\\02\\Starter\\func\\.gitignore**.

1. Exécutez la commande suivante afin d’utiliser **Azure Functions Core Tools** pour créer un projet Azure Functions local dans le répertoire actuel à l’aide du runtime **dotnet** :

    ```powershell
    func init --worker-runtime dotnet --force
    ```

    > **Remarque** : vous pouvez consultez la documentation pour [créer un projet][azure-functions-core-tools-new-project] à l’aide d’**Azure Functions Core Tools**.
    
1. Fermez l’application **Terminal Windows**.

#### Tâche 2 : Configurer une chaîne de connexion

1. Dans l’écran **Démarrage**, sélectionnez la vignette **Visual Studio Code**.
1. Dans le menu **Fichier**, sélectionnez **Ouvrir le dossier**.
1. Dans la fenêtre **Explorateur de fichiers** qui s’ouvre, accédez à **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**, puis choisissez **Sélectionner un dossier**.
1. Dans le volet **Explorateur** de la fenêtre **Visual Studio Code**, ouvrez le fichier **local.settings.json**.
1. Observez la valeur actuelle du paramètre **AzureWebJobsStorage**:

    ```json
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    ```

1. Remplacez la valeur de l’élément **AzureWebJobsStorage** par la **chaîne de connexion** du compte de stockage que vous avez enregistrée précédemment dans ce labo.
1. Enregistrez le fichier **local.settings.json**.

#### Tâche 3 : Créer et valider un projet

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Exécutez la commande suivante pour **générer** le projet .NET Core 3.1 :

    ```powershell
    dotnet build
    ```

#### Révision

Dans cet exercice, vous avez créé un projet local que vous allez utiliser pour le développement d’Azure Functions.

### Exercice 3 : Créer une fonction qui est déclenchée par une requête HTTP.

#### Tâche 1 : Créer une fonction déclenchée par HTTP

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Exécutez la commande suivante afin d’utiliser **Azure Functions Core Tools** pour créer une fonction nommée **Echo** à l’aide du modèle **Déclencheur HTTP** :

    ```powershell
    func new --template "HTTP trigger" --name "Echo"
    ```

    > **Remarque** : vous pouvez consultez la documentation pour [créer une fonction][azure-functions-core-tools-new-function] à l’aide d’**Azure Functions Core Tools**.

1. Fermez l’application **Terminal Windows** actuellement en cours d’exécution.

#### Tâche 2 : Écrire un code fonction déclenchée par HTTP

1. Dans l’écran **Démarrage**, sélectionnez la vignette **Visual Studio Code**.
1. Dans le menu **Fichier**, sélectionnez **Ouvrir le dossier**.
1. Dans la fenêtre **Explorateur de fichiers** qui s’ouvre, accédez à **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**, puis choisissez **Sélectionner un dossier**.
1. Dans le volet **Explorateur** de la fenêtre **Visual Studio Code**, ouvrez le fichier **Echo.cs**.
1. Dans l’éditeur de code, observez l’exemple d’implémentation:

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;
    namespace func
    {
        public static class Echo
        {
            [FunctionName("Echo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");
                string name = req.Query["name"];
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. Supprimez tout le contenu du fichier **Echo.cs**.
1. Ajoutez les lignes de code suivantes afin d’ajouter des **directives using** pour les espaces de noms **Microsoft.AspNetCore.Mvc**, **Microsoft.Azure.WebJobs**, **Microsoft.AspNetCore.Http**, and **Microsoft.Extensions.Logging** :

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    ```

1. Créez une classe **statique publique** nommée **Echo** :

    ```csharp
    public static class Echo
    { }
    ```

1. Observez à nouveau le fichier **Echo.cs**, qui devrait maintenant inclure :

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    public static class Echo
    { }
    ```

1. Dans la classe **Echo**, ajoutez le bloc de code suivant pour créer une méthode **statique publique** nommée **Run**, qui retourne une variable de type **IActionResult** et prend également des variables de type **HttpRequest** et **ILogger** en tant que paramètres nommés *request* et *logger* :

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. Ajoutez le code suivant pour ajouter un attribut à la méthode **Run** de type **FunctionNameAttribute** dont le paramètre **name** est défini sur la valeur **Echo** :

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. Ajoutez le code suivant pour ajouter un attribut au paramètre **request** de type **HttpTriggerAttribute** dont le tableau de paramètres **methods** est défini sur la valeur unique **POST** :

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        [HttpTrigger("POST")] HttpRequest request,
        ILogger logger)
    { }
    ```

1. Observez à nouveau le fichier **Echo.cs**, qui devrait maintenant inclure le code suivant:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        { }
    }
    ```

1. Dans la méthode **Run**, entrez la ligne de code suivante pour enregistrer un message fixe dans le journal :

    ```csharp
    logger.LogInformation("Received a request");
    ```

1. Entrez la ligne de code suivante pour faire écho au corps de la requête HTTP en tant que réponse HTTP :

    ```csharp
    return new OkObjectResult(request.Body);
    ```

1. Observez à nouveau le fichier **Echo.cs**, qui devrait maintenant inclure le code suivant:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        {
            logger.LogInformation("Received a request");
            return new OkObjectResult(request.Body);
        }
    }
    ```

1. Sélectionnez **Enregistrer** pour enregistrer vos modifications dans le fichier **Echo.cs**.

#### Tâche 3 : Tester la fonction déclenchée par HTTP à l’aide de httprepl

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Exécutez la commande suivante pour exécuter le projet d’application de fonction :

    ```powershell
    func start --build
    ```

    > **Remarque** : vous pouvez consultez la documentation pour [démarrer le projet d’application de fonction localement](https://docs.microsoft.com/azure/azure-functions/functions-develop-local) à l’aide d’**Azure Functions Core Tools**.
    
1. Dans la barre des tâches, sélectionnez à nouveau l’icône **Terminal Windows** pour ouvrir une nouvelle instance de l’application. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire vide **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```
    
1. Dans l’invite de commandes, exécutez la commande suivante pour installer et démarrer l’outil **httprepl**, en définissant l’URI (Uniform Resource Identifier) de base sur ``http://localhost:7071`` :

    ```powershell
    dotnet tool install -g Microsoft.dotnet-httprepl
    httprepl http://localhost:7071
    ```

    > **Remarque** : l’outil **httprepl** affiche un message d’erreur. Ce message apparaît parce que l’outil est en train de rechercher un fichier de définition Swagger à utiliser pour parcourir l’API. Étant donné que votre projet de fonction ne produit pas de fichier de définition Swagger, vous devez parcourir l’API manuellement.
1. Dans l’invite de l’outil, exécutez la commande suivante pour accéder au répertoire relatif **api** :

    ```powershell
    cd api
    ```

1. Exécutez la commande suivante pour accéder au répertoire relatif **echo** :

    ```powershell
    cd echo
    ```

1. Exécutez la commande suivante pour exécuter la commande **post** envoyant un corps de requête HTTP défini sur la valeur numérique **3** à l’aide de l’option **\-\-content** :

    ```powershell
    post --content 3
    ```

1. Exécutez la commande suivante pour exécuter la commande **post** envoyant un corps de requête HTTP défini sur la valeur numérique **5** à l’aide de l’option **\-\-content** :

    ```powershell
    post --content 5
    ```

1. Exécutez la commande suivante pour exécuter la commande **post** envoyant un corps de requête HTTP défini sur la valeur de chaîne **Hello** à l’aide de l’option **\-\-content** :

    ```powershell
    post --content "Hello"
    ```

1. Exécutez la commande suivante pour exécuter la commande **post** envoyant un corps de requête HTTP défini sur la valeur JSON (JavaScript Object Notation ) **{"msg": "Successful"}** à l’aide de l’option **\-\-content** :

    ```powershell
    post --content "{"msg": "Successful"}"
    ```

1. Exécutez la commande suivante pour quitter l’application **httprepl** :

    ```powershell
    exit
    ```

1. Fermez toutes les instances en cours d’exécution de l’application **Terminal Windows**.

#### Révision

Dans cet exercice, vous avez créé une fonction de base qui fait écho au contenu envoyé via une requête HTTP POST.

### Exercice 4 : Créer une fonction qui se déclenche selon une planification

#### Tâche 1 : Créer un fonction déclenchée par une planification

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Dans l’invite de commandes, exécutez la commande suivante afin d’utiliser **Azure Functions Core Tools** pour créer une fonction nommée **Recurring** en utilisant le modèle **Déclencheur de minuteur** :

    ```powershell
    func new --template "Timer trigger" --name "Recurring"
    ```

    > **Remarque** : vous pouvez consultez la documentation pour [créer une fonction][azure-functions-core-tools-new-function] à l’aide d’**Azure Functions Core Tools**.
    
1. Fermez l’application **Terminal Windows** actuellement en cours d’exécution.

#### Tâche 2 : Observer le code de la fonction

1. Dans l’écran **Démarrage**, sélectionnez la vignette **Visual Studio Code**.
1. Dans le menu **Fichier**, sélectionnez **Ouvrir le dossier**.
1. Dans la fenêtre **Explorateur de fichiers** qui s’ouvre, accédez à **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**, puis choisissez **Sélectionner un dossier**.
1. Dans le volet **Explorateur** de la fenêtre **Visual Studio Code**, ouvrez le fichier **Recurring.cs**.
1. Dans l’éditeur de code, observez l’implémentation :

    ```csharp
    using System;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Host;
    using Microsoft.Extensions.Logging;    
    namespace func
    {
        public static class Recurring
        {
            [FunctionName("Recurring")]
            public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
            {
                log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}");
            }
        }
    }
    ```

#### Tâche 3 : Observer les exécutions de la fonction

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Dans l’invite de commandes, exécutez la commande suivante pour exécuter le projet d’application de fonction:

    ```powershell
    func start --build
    ```

    > **Remarque** : vous pouvez consultez la documentation pour [démarrer le projet d’application de fonction localement][azure-functions-core-tools-start-function] à l’aide d’**Azure Functions Core Tools**.
1. Observez l’exécution de la fonction toutes les cinq minutes. Chaque exécution de la fonction devrait entraîner l’insertion d’un message simple dans le journal.
1. Fermez l’application **Terminal Windows** actuellement en cours d’exécution.

#### Tâche 4 : Mettre à jour la configuration d’intégration de la fonction

1. Dans l’écran **Démarrage**, sélectionnez la vignette **Visual Studio Code**.
1. Dans le menu **Fichier**, sélectionnez **Ouvrir le dossier**.
1. Dans la fenêtre **Explorateur de fichiers** qui s’ouvre, accédez à **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**, puis choisissez **Sélectionner un dossier**.
1. Dans le volet **Explorateur** de la fenêtre **Visual Studio Code**, ouvrez le fichier **Recurring.cs**.
1. Dans l’éditeur de code, observez la signature de la méthode **Run** existante:

    ```csharp
    [FunctionName("Recurring")]
    public void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. Mettez à jour le bloc de code de signature de la méthode **Run** pour modifier la planification de manière à ce que la fonction s’exécute une fois toutes les **30 secondes** :

    ```csharp
    [FunctionName("Recurring")]
    public void Run([TimerTrigger("*/30 * * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. Sélectionnez **Enregistrer** pour enregistrer vos modifications dans le fichier **Recurring.cs**.

#### Tâche 5 : Observer les exécutions de la fonction

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.

1. Exécutez la commande suivante pour remplacer le répertoire actuel par le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\...\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 1. Dans l’invite de commandes, exécutez la commande suivante pour exécuter le projet d’application de fonction :

    ```powershell
    func start --build
    ```
    
    > **Remarque** : vous pouvez consultez la documentation pour [démarrer le projet d’application de fonction localement][azure-functions-core-tools-start-function] à l’aide d’**Azure Functions Core Tools**.
    
1. Observez l’exécution de la fonction toutes les 30 secondes. Chaque exécution de la fonction devrait entraîner l’insertion d’un message simple dans le journal.

1. Fermez l’application **Terminal Windows** actuellement en cours d’exécution.

1. Fermez la fenêtre Visual Studio Code.

#### Révision

Dans cet exercice, vous avez créé une fonction qui s’exécute automatiquement en fonction d’une planification fixe.

### Exercice 5 : Créer une fonction qui s’intègre avec d’autres services

#### Tâche 1 : Charger l’exemple de contenu sur Stockage Blob Azure

1. Dans le volet de **navigation** du portail Azure, sélectionnez le lien **Groupes de ressources**.
1. Dans le volet **Groupes de ressources**, sélectionnez le groupe de ressources **Serverless** que vous avez créé précédemment dans ce labo.
1. Dans le volet **Serverless**, sélectionnez le compte de stockage **funcstor** _[votrenom]_ que vous avez créé précédemment dans ce labo.
1. Dans le volet **Compte de stockage**, dans la section **Conteneurs**, sélectionnez le lien **Stockage de données**.
1. Dans la section **Conteneurs**, sélectionnez **+ Conteneur**.
1. Dans la fenêtre contextuelle **Nouveau conteneur**, effectuez les actions suivantes, puis sélectionnez **Créer** :

    | Paramètre | Action |
    | -- | -- |
    | Zone de texte **Nom**  | Entrez **content** |
    | Liste déroulante **Niveau d’accès public**  | Sélectionnez **Privé (aucun accès anonyme)** |

1. Revenez à la section **Conteneurs**, puis sélectionnez le conteneur **content** créé récemment.
1. Dans le volet **Conteneur**, sélectionnez **Charger**.
1. Dans la fenêtre **Charger l’objet blob**, effectuez les actions suivantes, puis sélectionnez **Charger** :

    | Paramètre | Action |
    | -- | -- |
    | Section **Fichiers**  | Sélectionnez l’icône **Dossier** |
    | Fenêtre **Explorateur de fichiers**  | Accédez à **Allfiles (F):\\Allfiles\\Labs\\02\\Starter**, sélectionnez le fichier **settings.json**, puis **Ouvrir** |
    | Case à cocher **Remplacer si les fichiers existent déjà** | Vérifiez que cette case est cochée |

      > **Remarque** : attendez que le chargement du blob soit terminé avant de poursuivre ce labo.

#### Tâche 2 : Créer une fonction déclenchée par HTTP

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Dans l’invite de commandes, exécutez la commande suivante afin d’utiliser **Azure Functions Core Tools** pour créer une fonction nommée **GetSettinginfo** en utilisant le modèle **Déclencheur HTTP** :

    ```powershell
    func new --template "HTTP trigger" --name "GetSettingInfo"
    ```

    > **Remarque** : vous pouvez consultez la documentation pour [créer une fonction][azure-functions-core-tools-new-function] à l’aide d’**Azure Functions Core Tools**.
1. Fermez l’application **Terminal Windows** actuellement en cours d’exécution.

#### Tâche 3 : Écrire un code de fonction déclenché par HTTP et entré par blob

1. Dans l’écran **Démarrage**, sélectionnez la vignette **Visual Studio Code**.
1. Dans le menu **Fichier**, sélectionnez **Ouvrir le dossier**.
1. Dans la fenêtre **Explorateur de fichiers** qui s’ouvre, accédez à **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**, puis choisissez **Sélectionner un dossier**.
1. Dans le volet **Explorateur** de la fenêtre **Visual Studio Code**, ouvrez le fichier **GetSettingInfo.cs**.
1. Dans l’éditeur de code, observez l’exemple d’implémentation:

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;    
    namespace func
    {
        public static class GetSettingInfo
        {
            [FunctionName("GetSettingInfo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");    
                string name = req.Query["name"];    
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;    
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";    
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. Supprimez tout le contenu du fichier **GetSettingInfo.cs**.

1. Ajoutez les lignes de code suivantes afin d’ajouter des **directives using** pour les espaces de noms **Microsoft.AspNetCore.Http**, **Microsoft.AspNetCore.Mvc** et **Microsoft.Azure.WebJobs** :

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    ```

1. Créez une classe **statique publique** nommée **GetSettingInfo** :

    ```csharp
    public static class GetSettingInfo
    { }
    ```

1. Observez à nouveau le fichier **GetSettingInfo.cs**, qui devrait maintenant inclure le code suivant:

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    public static class GetSettingInfo
    { }
    ```

1. Dans la classe **GetSettingInfo**, ajoutez le bloc de code suivant pour créer une méthode expression-bodied **statique publique** nommée **Run**, qui retourne une variable de type **IActionResult** et prend également des variables de type **HttpRequest** et **string** en tant que paramètres nommés *request* et *json*:

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

    > **Remarque** : vous définissez uniquement temporairement la valeur de retour sur **null**.

1. Ajoutez le code suivant pour ajouter un attribut à la méthode **Run** de type **FunctionNameAttribute** dont le paramètre **name** est défini sur la valeur **GetSettingInfo** :

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

1. Ajoutez le code suivant pour ajouter un attribut au paramètre **request** de type **HttpTriggerAttribute** dont le tableau de paramètres **methods** est défini sur la valeur unique **GET** :

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        string json)
        => null;
    ```

1. Ajoutez le code suivant afin d’ajouter un attribut au paramètre **json** de type **BlobAttribute** dont le paramètre **blobPath** est défini sur la valeur **content/settings.json** :

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => null;
    ```

1. Ajoutez le code suivant afin de mettre à jour la méthode expression-bodied **Run** pour retourner une nouvelle instance de la classe **OkObjectResult** transmettant la valeur du paramètre de méthode **json** comme unique paramètre de constructeur :

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => new OkObjectResult(json);
    ```

1. Observez à nouveau le fichier **GetSettingInfo.cs**, qui devrait maintenant inclure le code suivant:

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    public static class GetSettingInfo
    {
        [FunctionName("GetSettingInfo")]
        public static IActionResult Run(
            [HttpTrigger("GET")] HttpRequest request,
            [Blob("content/settings.json")] string json)
            => new OkObjectResult(json);
    }
    ```

1. Sélectionnez **Enregistrer** pour enregistrer vos modifications dans le fichier **GetSettingInfo.cs**.

#### Tâche 4 : Inscrire les extensions Azure Storage Blob

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Dans l’invite de commandes, exécutez la commande suivante pour inscrire l’extension [Microsoft.Azure.WebJobs.Extensions.Stockage](https://www.nuget.org/packages/Microsoft.Azure.WebJobs.Extensions.Storage/) :

    ```powershell
    func extensions install --package Microsoft.Azure.WebJobs.Extensions.Storage --version 5.0.1
    ```

1. Exécutez la commande suivante pour générer le projet .NET et confirmer que les extensions ont été installées correctement :

    ```powershell
    dotnet build
    ```

1. Fermez toutes les instances en cours d’exécution de l’application **Terminal Windows**.

#### Tâche 5 : Tester la fonction à l’aide de httprepl

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Dans l’invite de commandes, exécutez la commande suivante pour exécuter le projet d’application de fonction :

    ```powershell
    func start --build
    ```

    > **Remarque** : vous pouvez consultez la documentation pour [démarrer le projet d’application de fonction localement][azure-functions-core-tools-start-function] à l’aide d’**Azure Functions Core Tools**.
1. Dans la barre des tâches, sélectionnez à nouveau l’icône **Terminal Windows** pour ouvrir une nouvelle instance de l’application **Terminal Windows**.
1. Dans l’invite de commandes, exécutez la commande suivante pour démarrer l’outil **httprepl**, en définissant l’URI (Uniform Resource Identifier) de base sur ``http://localhost:7071`` :

    ```powershell
    httprepl http://localhost:7071
    ```

    > **Remarque** : l’outil **httprepl** affiche un message d’erreur. Ce message apparaît parce que l’outil est en train de rechercher un fichier de définition Swagger à utiliser pour parcourir l’API. Étant donné que votre projet de fonction ne produit pas de fichier de définition Swagger, vous devez parcourir l’API manuellement.

1. Lorsque vous recevez l’invite de l’outil, exécutez la commande suivante pour accéder au point de terminaison relatif **api** :

    ```powershell
    cd api
    ```

1. Exécutez la commande suivante pour accéder au point de terminaison relatif **getsettinginfo** :

    ```powershell
    cd getsettinginfo
    ```

1. Exécutez la commande suivante afin d’exécuter la commande **get** pour le point de terminaison actuel :

    ```powershell
    get
    ```

1. Observez le contenu JSON de la réponse de l’application de fonction, qui devrait maintenant inclure :

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```

1. Exécutez la commande suivante pour quitter l’application **httprepl** :

    ```powershell
    exit
    ```

1. Fermez toutes les instances en cours d’exécution de l’application **Terminal Windows**.

#### Révision

Dans cet exercice, vous avez créé une fonction qui retourne le contenu d’un fichier JSON dans Stockage.

### Exercice 6 : Déployer un projet de fonction local sur une application Azure Functions

#### Tâche 1 : Déployer à l’aide d’Azure Functions Core Tools

1. Dans la barre des tâches, sélectionnez l’icône **Terminal Windows**.
1. Exécutez la commande suivante pour modifier le répertoire actuel en le définissant sur le répertoire **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** :

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. Dans l’invite de commandes, exécutez la commande suivante pour vous connecter à l’interface de ligne de commande (CLI) Azure :

    ```powershell
    az login
    ```

1. Dans la fenêtre de navigateur **Microsoft Edge**, entrez le nom et le mot de passe du compte Microsoft ou Azure Active Directory que vous utilisez dans ce labo, puis sélectionnez **Se connecter**.
1. Revenez à la fenêtre **Terminal Windows** actuellement ouverte. Attendez la fin du processus de connexion.
1. Dans l’invite de commandes, exécutez la commande suivante pour publier le projet d’application de fonction (remplacez l’espace réservé `<function-app-name>` par le nom de l’application de fonction que vous avez créée précédemment dans ce labo) :

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **Remarque** : par exemple, si votre **Nom d’application de fonction** est **funclogicstudent**, votre commande sera ``func azure functionapp publish funclogicstudent``. Vous pouvez consulter la documentation pour [publier le projet d’application de fonction local][azure-functions-core-tools-publish-azure] à l’aide d’**Azure Functions Core Tools**.

1. Attendez que le déploiement soit finalisé avant de poursuivre le labo.
1. Fermez l’application **Terminal Windows** actuellement en cours d’exécution.

#### Tâche 2 : Valider le déploiement

1. Dans la barre des tâches, sélectionnez l’icône **Microsoft Edge**, puis l’onglet qui affiche le portail Azure (<https://portal.azure.com>).
1. Dans le volet de **navigation** du portail Azure, sélectionnez le lien **Groupes de ressources**.
1. Dans le volet **Groupes de ressources**, sélectionnez le groupe de ressources **Serverless** que vous avez créé précédemment dans ce labo.
1. Dans le volet **Serverless**, sélectionnez l’application de fonction **funclogic** _[votrenom]_ que vous avez créée précédemment dans ce labo.
1. Dans le volet **Application de fonction**, sélectionnez l’option **Fonctions** dans la section **Fonctions**.
1. Dans le volet **Fonctions**, sélectionnez la fonction **GetSettingInfo** existante.
1. Dans le volet **Fonction**, dans la section **Développeur**, sélectionnez l’option **Code + Test**.
1. Dans l’éditeur de fonction, sélectionnez **Tester/Exécuter**.
1. Dans le volet affiché automatiquement, dans la liste déroulante **Méthode HTTP**, sélectionnez **GET**.
1. Sélectionnez **Exécuter** pour tester la fonction.
1. Dans le **contenu de la réponse HTTP**, passez en revue les résultats de la série de tests. Le contenu JSON devrait maintenant inclure le code suivant:

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```

#### Révision

Dans cet exercice, vous avez déployé un projet de fonction local dans Azure Functions et vérifié que les fonctions opèrent dans Azure.

### Exercice 7 : Nettoyer votre abonnement

#### Tâche 1 : Ouvrir Azure Cloud Shell et répertorier les groupes de ressources

1.  Dans le portail Azure, sélectionnez l’icône **Cloud Shell** ![icône Cloud Shell](./media/az204_lab_CloudShell.png) pour ouvrir une nouvelle session Bash. Si Cloud Shell est défini par défaut sur une session PowerShell, sélectionnez **PowerShell**, puis, dans le menu déroulant, sélectionnez **Bash**.

    > **Remarque** : si vous démarrez **Cloud Shell** pour la première fois, lorsque vous êtes invité à sélectionner **Bash** ou **PowerShell**, sélectionnez **PowerShell**. Lorsque vous voyez le message **Vous n’avez aucun stockage monté**, sélectionnez l’abonnement que vous utilisez dans ce labo, puis choisissez **Créer un stockage**.

#### Tâche 2 : Supprimer un groupe de ressources

1. Dans le volet **Cloud Shell**, exécutez la commande suivante pour supprimer le groupe de ressources **Serverless**:

    ```powershell
    az group delete --name Serverless --no-wait --yes
    ```
     > **Remarque** : La commande s’exécute de façon asynchrone (comme déterminé par le paramètre *--no-wait*). Par conséquent, vous êtes en mesure d’exécuter une autre commande Azure CLI immédiatement après au cours de la même session Bash, mais la suppression du groupe de ressources prendra quelques minutes.

1. Fermez le volet **Cloud Shell** dans le portail.

#### Tâche 3: Fermer l’application active

- Fermez l’application Microsoft Edge en cours d’exécution.

#### Révision

Dans cet exercice, vous avez nettoyé votre abonnement en supprimant le groupe de ressources utilisé dans ce labo.
